\chapter{Experimental Methods: Digital Locks with PyRPL} \label{chap:locks}
This chapter essentially covers feedback control techniques used in Chapter IV and V. It is thought as a practical guide to the implementation of various locking schemes using the LKB \textit{home grown} control software PyRPL. The chapter begins with a general introduction to feedback control, PI controllers and error signal requirements. It then details specific locking techniques used in this work, with an emphasis on experimental aspects. For in depth technical description of the PyRPL working principle, we refer the reader to Chapter III or L. Neuhaus thesis \cite{neuhaus}, as well as the PyRPL documentation \cite{PyRPLDocs} and original article \cite{PyRPL2024}. Some figures are adapted from this last reference (with authorization)
\minitoc
\newpage
\section{Feedback control}
A central aspect of experimental quantum optics is the ability to stabilize various parameters of an optical setup against environmental fluctuations. A feedback control loop then aims to stabilize the behaviour of a physical system that is continuously subject to disturbances. These parameters include cavity lengths, laser frequencies, optical phases, and temperatures of nonlinear crystals, which all undergo unwanted drifts and noise due to thermal, acoustic, and mechanical perturbations. To achieve this stabilization, feedback control systems are employed, which rely on generating an error signal that quantifies the deviation from a desired setpoint. This error signal is then processed by a controller to compute a corrective feedback signal that drives an actuator to counteract the disturbance and maintain the parameter at its target value.

\subsection{Overview}

When the system may be linearized around its operating point, its response to a harmonic perturbation at angular frequency $\omega_0$ is fully characterized by its complex transfer function $G(\omega)$ \cite{feedback_physicists}. We denote by $V_{\mathrm{exc}}(t)$ the real excitation applied to the system, taken to be sinusoidal,
\begin{equation}
V_{\mathrm{exc}}(t) = A_{\mathrm{exc}} \cos(\omega_0 t),
\label{eq:Vexc}
\end{equation}
with amplitude $A_{\mathrm{exc}}$.  
In the frequency domain the system is described by its complex transfer function
\begin{equation}
G(\omega) = |G(\omega)| e^{i\phi(\omega)},
\label{eq:Gomega}
\end{equation}
which specifies the amplitude response $|G(\omega)|$ and the phase shift $\phi(\omega)$ experienced by a sinusoid at frequency $\omega$. The relation between input and output is expressed most naturally in complex notation.  
Writing the excitation as the real part of a complex exponential,
\[
V_{\mathrm{exc}}(t)= \Re\!\left\{A_{\mathrm{exc}} e^{i\omega_0 t}\right\} \implies V_{\mathrm{meas}}(t)
= \Re\!\left\{\, G(\omega_0)\, A_{\mathrm{exc}} e^{i\omega_0 t} \right\}
\]
so that explicitly
\begin{equation}
V_{\mathrm{meas}}(t)
= |G(\omega_0)| A_{\mathrm{exc}}
  \cos\!\left(\omega_0 t + \phi(\omega_0)\right).
\label{eq:Vmeas}
\end{equation}
Thus the physical output remains real, while the complex transfer function $G(\omega_0)$ determines how the amplitude and phase of the input harmonic are modified.

\subsubsection{In-phase and quadrature decomposition.}
It is convenient to decompose the transfer function into its in-phase (I) and quadrature (Q) components such that Eq.~\eqref{eq:Vmeas} can be written as
\begin{equation}
V_{\mathrm{meas}}(t)
= I(\omega_0)\cos(\omega_0 t)
  + Q(\omega_0)\sin(\omega_0 t),
\label{eq:IQreal}
\end{equation}
which forms the basis of IQ demodulation.  
By multiplying $V_{\mathrm{meas}}(t)$ by $\cos(\omega_0 t)$ and $\sin(\omega_0 t)$ and low-pass filtering the results with a filter $H_f(\omega)$ with a cutoff frequency $\omega_f \ll \omega_0$ (such that the $2\omega_0$ components vanish), one obtains the slowly varying quadratures
$\,I(t)$ and $Q(t)$, from which the complex baseband signal
\begin{equation}
s_{\mathrm{meas}}(t) = I(\omega_0) + i\,Q(\omega_0)
\end{equation}
is constructed.  \\  

Obviously, realistic excitation signals are never pure sinusoids, such that they can be decomposed into a superposition of harmonic components
\begin{equation*}
V_{\mathrm{exc}}(t) = \Re{\int_{0}^{\infty} \dfrac{d\omega}{2\pi} \, A_{\mathrm{exc}}(\omega) \, e^{i\omega t}}.
\end{equation*} 
where $A_{\mathrm{exc}}(\omega)$ is the complex amplitude of the component at angular frequency $\omega$. Demodulating the measured signal at a frequency $\omega_0$ and low pass filtering it yields a measured signal given by 
\begin{equation}
\begin{split}
s_{\mathrm{meas}}(t) &= \int_{0}^{\infty} \dfrac{d\omega}{2\pi} \, G(\omega- \omega_0) H_f(\omega) \, A_{\mathrm{exc}}(\omega-\omega_0) \, e^{i\omega t} \\
& = I(t) + i \, Q(t)
\end{split}
\end{equation}
such that the IQ demodulation produces time-dependent quadratures $I(t)$ and $Q(t)$, whose complex combination $s_{\mathrm{meas}}(t)$ represents the slowly varying complex envelope. \\ 

In a feedback loop, a relevant observable derived from $s_{\mathrm{meas}}(t)$ is fed into the controller and is denoted $s_{\mathrm{in}}(t)$. Depending on the application, $s_{\mathrm{in}}(t)$ may correspond to one of the quadratures, the reconstructed phase, or any real-valued function of $(I,Q)$. 


\subsection{Proportion-Integral (PI) Controllers}
Now that both quadratures are accessible through the IQ demodulation, and that we obtained a signal $s_{\mathrm{in}}(t)$ relevant for the control task at hand, we need to extract an error signal \( \varepsilon(t) \) that quantifies the deviation from a desired setpoint at which we wish to \textit{lock} the system. It is typically expressed as the difference between a measured signal and its reference value:
\begin{equation}
    \varepsilon(t) = s_{\text{in}}(t) - s_{\text{ref}},
\end{equation}
where \( s_{\text{in}}(t) \) is the physical quantity monitored in the experiment, and \( s_{\text{ref}} \) is the target value.\\ 

For effective feedback stabilization, this error signal must satisfy several essential criteria listed below. \\ 

\noindent \textbf{High SNR: }
Near the setpoint, \( \varepsilon(t) \) should exhibit a high SNR to ensure robust locking and minimize the influence of technical and electronic noise. \\ 

\noindent \textbf{Linearity and antisymmetry: }
The error signal should be linear and antisymmetric in a neighborhood of the operating point. Small deviations from the setpoint should produce a proportional response in \( \varepsilon(t) \), with opposite signs for deviations of opposite direction. \\

\noindent \textbf{Monotonicity and uniqueness: }
The slope \( \partial \varepsilon / \partial x \), where \( x \) denotes the control parameter (e.g., cavity length or laser frequency), should be monotonic and unambiguous near the lock point to avoid multiple equilibrium points and ensure stable locking behavior. \\

\noindent \textbf{Steep slope near the setpoint: }
A steeper slope improves sensitivity to small deviations and enhances lock accuracy, although it must be balanced against potential noise amplification. \\

\noindent \textbf{Bandwidth compatibility: }
The spectral content of \( \varepsilon(t) \) must be compatible with the bandwidth of the actuator and the dynamics of the system. For example, in the case of a piezoelectric transducer, which acts as a low-pass mechanical element, the error signal high-frequency components won't be compensated by the actuator.  \\ 

A standard way to achieve this stabilization is to use a Proportion-Integral (PI) controller. The PI controller computes the feedback signal \( u(t) \) from the error signal \( \varepsilon(t) \) according to:
\begin{equation}
    s_{\text{out}}(t) = K_P \, \varepsilon(t) + K_I \int_0^t \varepsilon(\tau) d\tau
    \tag{III.1}
\end{equation}
where \( K_P \) and \( K_I \) are the proportional and integral gains, respectively. The proportional term \( K_P \, \varepsilon(t) \) responds to the current error and primarily acts on mid-frequency deviations, enabling rapid corrections. The integral term \( K_I \int \varepsilon(\tau) d\tau \) accumulates past errors and is most effective at low frequencies, helping to eliminate long-term drifts and steady-state offsets. \\ 

In classical control theory, PID (Proportional-Integral-Derivative) controllers are designed to stabilize dynamic systems by combining three terms: a proportional term for immediate response, an integral term to eliminate steady-state error, and a derivative term that anticipates future error based on the rate of change. However, in practical experimental setups—particularly in quantum optics—PI control (Proportional-Integral) is typically sufficient and even preferable to full PID control. The derivative term, which acts predominantly at high frequencies, is generally unnecessary and can be counterproductive. This is because the feedback actuator is often a piezoelectric transducer, which exhibits non-zero capacitance. Combined with the finite output impedance of the control electronics, this forms a natural low-pass filter that significantly attenuates high-frequency components of the feedback signal. As a result, any derivative term—which primarily targets high-frequency correction—would be both ineffective due to this filtering and potentially harmful by injecting high-frequency noise into the loop. \newline 

Therefore, PI control offers a balanced and robust approach: the integral term suppresses low-frequency drifts (typically below a few Hz to tens of Hz), the proportional term corrects intermediate-frequency deviations (up to a few kHz), and high-frequency components (above the mechanical resonance or actuation bandwidth) are naturally filtered out and deliberately left uncorrected. Furthermore, and due to the limited computational power of the FPGA board, it was removed by design. This nonetheless allows for stable, qualitative feedback while preserving high-frequency signals—such as thermal noise or mechanical sidebands—which carry essential physical information for analysis and measurement.


\subsection{PyRPL overview}
With the rise of digital signal processing, many feedback control systems have transitioned from analog electronics to software-based implementations. One such powerful and flexible platform is PyRPL (Python Red Pitaya Lockbox), an open-source software suite designed for real-time digital signal processing and feedback control using the Red Pitaya (RP) hardware and developed in our team at LKB. A RP is a small, low-cost FPGA-based measurement and control platform that combines fast ADC/DAC converters with programmable digital logic, as well as an embedded processor. In practice, it is used as a \textit{reconfigurable instrument} (oscilloscope/ASG/filters/PID) whose signal processing can run in real time at high bandwidth: PyRPL leverages this hardware to implement various digital signal processing tasks, while providing flexibility through a Python API and a graphical user interface (GUI), showcased by its integration in many experimental setups worldwide \cite{LukinNature2025,Suzuki25}. While we refer the reader to Leonhard Neuhaus' thesis \cite{neuhaus} and the PyRPL documentation and paper \cite{PyRPLDocs,PyRPL2024} for an in-depth technical description of the PyRPL working principle, we will concisely summarize the main performance metrics and high abstraction blocks relevant for this work. \\

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/signals.pdf}
    \caption{Schematic overview of the DSP modules (ASG, IIR, IQ demodulators, PID controllers, scope) and their interconnections through a configurable DSP multiplexer. Signals originating from the analog inputs (In1, In2) or internal blocks are routed to processing modules and/or directly to the outputs. Contributions directed to each analog output are summed in the output-summation stage prior to conversion by the on-board DACs (Out1, Out2).}\label{fig:signal}
\end{figure} 

Red Pitayas are compact FPGA-based platforms that combine high-speed analog-to-digital (ADC) and digital-to-analog (DAC) converters with a powerful FPGA for real-time signal processing. In practice, the FPGA hosts a set of digital signal processing (DSP) modules (e.g. mixers/IQ demodulators, digital filters and PID controllers) that can be interconnected as shown in Fig.\cite{fig:signal}, to implement low-latency measurement and feedback chains directly in hardware. The onboard ADCs and DACs operate at a 125\,MHz sampling rate with 14-bit nominal resolution, which enables the digitization and synthesis of signals up to about 60\,MHz (the Nyquist criterion). The effective resolution is about 12\,bits for the ADC and 11\,bits for the DAC, which remains more than sufficient for precision photodetection, modulation, and error-signal processing in quantum optics. A notable limitation is the digitization noise floor i.e. $2V/2^{14} \sim 122 \mu$V, as well as the noise added from the voltage shifter, bounding the output to $\pm 1V$. Sensible improvement of the order of 5 dBm/Hz can be achieved in the 100 Hz-1 MHz frequency range by unsoldering the voltage shifter circuit, as well as taking of the regulator from the board and powering the Red Pitaya with a low noise external voltage source \cite{neuhaus_blog}. Taking the voltage offset off actually makes the output range 0-2V, ideal as to not feed (high voltage amplified) negative voltages to piezoelectric actuators (which would kill them). This modification was performed on all RPs used in this work, bringing the noise floor down to 140dBM/Hz at 1MHz. \\

PyRPL leverages this hardware to implement various digital signal processing tasks. The modules available in PyRPL are a scope, a spectrum analyser, 2 Arbitrary Signal Generators (ASG), 3 PID controllers, 3 IQ modules, an Infinite Impulse Response (IIR) filter module, and 4 pulse width modulation modules (pwm). These modules can be interconnected in a flexible manner to create complex feedback loops tailored to specific experimental needs, by simply rerouting the signal flow either in a programmatic way using the PyRPL Python API, or graphically through the PyRPL GUI. The signal flow architecture is illustrated in figure \ref{fig:signal}, where one can see how the various modules can be interconnected. This makes PyRPL a very versatile and cheap tool for monitoring and piloting a wide range of experimental setups. \\

An additional experimental tricks to circumvent the number of output issues (2 DAC channels only) is to use the slow analog outputs of the RP, which need to be soldered manually to BNC/SMA outputs. These outputs send 4 0-1.8V signals synthesized from filtered pwm signals, have a sensibly noisier floor as well as a limited bandwidth (up to $\sim$100kHz only), but are very useful for sending DC offsets as well as slow feedback signals. Additionally, we make extensive use of Mini-Circuits bias tees, amplifiers and filters to direct both slow and RF signals to the same output, as to be able to artifically double the number of output channels (2 RF + 2 DC). Another yet more complex solution is to use multiple RPs synchronized together through a common reference clock and trigger, to build more complex feedback systems \cite{croquette}.  


\subsection{IQ modules}
We now turn more specifically to the PyRPL IQ modules, which can be used for various purposes. Using the Python API or the GUI, one can select which input channel (In1 or In2) is fed to the IQ module. Similarly, one can chose to which output channel (Out1 or Out2) the processed signal is sent. In between, various registers allow the user to manipulate the input signal as desired. The latent available operations of the module are illustrated in figure \ref{fig:IQs}. The input signal can first be high pass filtered to eventually remove DC offsets. It is then mixed with the $\cos \omega_0 t$ and $\sin \omega_0 t$ signals discussed above, with an additional phase shift $\phi$ that can be set by the user. They are then lowpass filtered to yield the in-phase and quadrature components \( I(t) \) and \( Q(t) \). Finally, these quadratures can be manipulated in various ways before being sent to the output channel, or sent to other modules such as the scope or the spectrum analyzer for diagnostic purposes. \\ 
    
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/IQraww.pdf}
    \caption{
        Basic working principle of the IQ module in PyRPL. One can set any register value using either the GUI or the Python API to manipulate the input signal as desired.
    }\label{fig:IQs}
\end{figure}

\noindent \textbf{Filters: } setting the various registers as in fig \ref{fig:IQuserB}(a), one can choose to lowpass, highpass or bandpass an input signal by chosing the cutoff frequencies the filter orders. \\

\noindent \textbf{Network Analyzer: } by setting the registers as in fig \ref{fig:IQuserB}(b), one can use the IQ module as a network analyzer. The input signal is swept over a user-defined frequency range, and the in-phase and quadrature components are recorded at each frequency step. This allows to reconstruct the complex transfer function of a system connected to the input channel, which is very useful for characterizing the response of feedback loops. \\

\noindent \textbf{Phase Lock Loop: } by setting the registers as in fig \ref{fig:IQuserB}(c), one can use the IQ module as a phase lock loop (PLL). The phase of the input signal is continuously monitored through the IQ demodulation, and a feedback signal is generated. This error signal computed using CORDIC (an efficient algorithm eventually computing $\arctan{I;Q}$), then needs to be routed to the PID modules to lock the phase to a desired reference value. This is particularly useful for stabilizing optical phases in interferometric setups, as well as implemental frequency offset locks and PLLs. \\

\noindent \textbf{Error Signals - Lock-in Detection: } by setting the registers as in fig \ref{fig:IQuserB}(d), one can use the IQ module to generate error signals for feedback control. The user can select which quadrature (I or Q) is sent to the output channel, as well as apply additional processing such as scaling, offsetting, or filtering. An in-phase modulation generated on the FPGA using a LookUp table can be sent off to an EOM, and AOM or a PZT to implement locks.
This allows to tailor the error signal to the specific requirements of the feedback loop, ensuring optimal performance and stability. \\ 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/IQuserB.pdf}
    \caption{Various reprogrammings of the IQ module to perform (a) filtering, (b) network analysis, (c) phase lock loop and (d) error signal generation (Dither/PDH).}
    \label{fig:IQuserB}
\end{figure} 



\section{Locking techniques}
We now proceed to give a list of the various locks used in this work, along with their practical implementation as well as their error signal expression. Additionally, the RP allows for systematic and automated recalibration of the predicted error signals, which is very useful to maintain optimal locking conditions over long periods of time. The details of the derivations of the error signals are given in Appendix B. \\ 
\subsection{Temperature Lock}
A first example of a PI lock used in this work is the temperature lock, which is used to stabilize the temperature of non linear crystals embedded inside optical cavities. The error signal is derived from a temperature sensor, such as a thermistor, which measures the temperature of the crystal and simply written as:
\begin{equation}
\varepsilon(\Delta T) \propto \Delta T 
\end{equation}
where \( \Delta T = T_{\text{meas}} - T_{\text{set}} \).
The error signal is then fed into a PI controller, which adjusts the heating element, a peltier module in our case, to maintain the desired temperature setpoint. In the case of our SHG, temperature lock is actually performed using a commercial temperature controller provided along the PPLN crystal array provided by Covesion. Similarly, the OPO crystal temperature is stabilized using a Thorlabs TED200C temperature controller connected to a thermistor and a peltier module, the RP just allowing us to module the lock point by feeding an offset voltage to the temperature controller. On a side note, the RP is not able to send the current needed for the Peltier module operation, and its bandwidth would be a wasted ressource. \\

A full PyRPL lock has however been implemented on the quantum thermometry experiment led by Tristan Briant, and the details of this implementation can be found in the thesis of Emile Ferreux. The RP wiring diagram is shown in figure \ref{fig:TLock}. \\ 

The temperature lock is crucial for maintaining the phase matching conditions in nonlinear optical processes (developped in the next section), such as second-harmonic generation or optical parametric oscillation, where the efficiency of frequency conversion depends sensitively on the crystal temperature. By stabilizing the temperature, we ensure that the nonlinear interactions remain optimal, leading to consistent and reproducible results in experiments involving squeezed light generation or other nonlinear optical phenomena. \\ 


\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/Tlock.pdf}
    \caption{RP wiring and expected error signal for a temperature lock. The thermistor characteristic response (usually an exponential function) needs to be calibrated to convert the voltage signal into temperature units.}
    \label{fig:TLock}
\end{figure} 


\subsection{Optical phase Lock}
Controlling the relative path length between two arms of an interferometer is a fundamental technique in quantum optics. The basic idea is to use the interference of light from two paths to lock the phase difference between them. Although not being the same experiental setups, Michelson interferometers, Mach-Zhender interferometers, and Local Oscillator stabilization error signals fall in the same category as they are derived from the same principle. Namely, the error signal is proportional to the sine of the phase difference between the two arms: 
\begin{equation}
\varepsilon(\Delta\phi) \propto \sin(\Delta\phi) \simeq \Delta\phi 
\end{equation}
where $\Delta \phi = \phi_a - \phi_b$ is the phase difference between the two optical paths. Analogically, we would need to add an adjustable voltage offset, as to be able to tune the error signal to zero at the desired phase difference, before seeding this error signal to the PI block. Digitally, this is performed by adding a constant offset to the error signal, which can be adjusted to set the desired phase difference. \\

In practice, this is implemented by mounting a mirror on which one of the arms is reflected, and then using a piezoelectric transducer to control the position of the mirror, hence modulating the relative phase between the two optical paths. The piezo is then feedback controlled through a PI loop, which adjusts the voltage applied to the piezo to set the error signal to 0. The RP wiring diagram is shown in figure \ref{fig:Tphase}.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/Tphase.pdf}
    \caption{Typical RP wiring for an optical phase lock using (a) a Michelson interferometer, (b) a Mach-Zehnder interferometer or (c) a local oscillator phase lock. The error signal is derived from the interference pattern detected on a photodiode, and is fed into a PI controller to adjust the piezoelectric actuator controlling the optical path length. High voltage amplifiers are often used to drive the piezo with sufficient voltage range. (d) Expected error signal shape as a function of the phase difference between the two arms. The lock point can be adjusted by adding a constant offset to the error signal.}
    \label{fig:Tphase}
\end{figure} 
\subsection{Cavity Locks}
We now turn to the locking of optical cavities, and will develop 3 techniques used in this work: the side of fringe lock, the dither lock and the Pound-Drever-Hall (PDH) lock. The RP wiring and the typical error signal shapes are shown in figure \ref{fig:Tcav}. \\
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/Tcav.pdf}
    \caption{(a) RP wiring for Dither and PDH locks, where a modulation is sent to either a piezoelectric actuator controlling the cavity length, or to an EOM modulating the phase of the incident light. The reflected or transmitted signal is then demodulated using an IQ module to generate the error signal, which is fed into a PI controller to stabilize the cavity on resonance. (b) Typical error signal shapes for side of fringe (blue), dither (green) and PDH locks (red) as a function of the cavity detuning $\Delta \omega$.}
    \label{fig:Tcav}
\end{figure} 
\subsubsection{Side of Fringe}
A lorentzian dip does not qualify as a valid error signal to lock the cavity on resonance, according to the requirements listed above, as it is symmetric around resonance. However, by locking the cavity on the side of the resonance fringe, one can obtain a usable error signal that is linear and antisymmetric in a small neighborhood around the lock point. This technique is known as the \textit{side of fringe} lock. The error signal near resonance is then given by
\begin{equation}
\varepsilon(\Delta \omega) \propto (\Delta \omega - \Delta_{\text{lock}})
\end{equation}
where the $\Delta_{\text{lock}}$ is the detuning at which the cavity is locked. In PyRPL, calibrating the lorentzian dip in transmission or reflection allows to set the lock point in units of the cavity linewidth, which is very convenient. This would also allow to explore off resonant optomechanical effects, such as optical spring and damping. \\ 

The side of fringe lock is almost always used in this work as a preliminary step to bring the cavity close to resonance before engaging a more sophisticated lock such as PDH or dither lock. However, it is less robust and sensitive compared to other techniques, making it less suitable for long-term stabilization or high-precision applications. 

\subsubsection{Dither lock}
A first technique to lock an optical cavity on resonance is the dither lock. The basic idea is to impose a small sinusoidal modulation modulating the cavity resonant frequency, typically by applying a phase modulation using an EOM, or by modulating the cavity length using a piezoelectric actuator. Linking this to the IQ section above, we would modulate the cavity at frequency \(\omega_0 \lesssim \kappa\) with $\kappa$ the cavity linewidth, and demodulate the reflected or transmitted signal at the same frequency using an IQ module. The error signal is then proportional to the in-phase or quadrature component of the demodulated signal, depending on the demodulation phase chosen. The error signal near resonance is then given by
\begin{equation}
\varepsilon(\Delta \omega) \propto \Delta \omega
\end{equation}
This technique is relatively simple to implement and can provide a robust lock, although it may introduce additional noise due to the imposed modulation. The modulation frequency, phase and depth need to be carefully chosen to optimize the lock performance while minimizing the impact on the system's dynamics. This technique has the advantage of being implementable with the transmitted signal of the cavity (while PDH requires the reflected signal), since the modulation frequency is lower than the cavity linewidth (otherwise the sidebands would only be reflected). 

\subsubsection{Pound-Drever-Hall Lock}
The second method to lock an optical cavity on resonance is the Pound-Drever-Hall (PDH) technique \cite{drever83}, which can be used to lock a laser frequency to a stable optical cavity, or conversely to lock the cavity length to a stable laser frequency. 
The method relies on imposing phase modulation sidebands on the laser field outside the cavity bandwidth this time, typically using an electro-optic modulator (EOM), and using these sidebands as phase-stable references. Because they lie far outside the cavity linewidth (\( \Omega_{\text{mod}} \gg \kappa \)), the sidebands are reflected nearly unchanged: \( r(\omega_\ell \pm \Omega_{\text{mod}}) \approx 1 \). In contrast, the carrier field near resonance acquires a frequency-dependent phase shift upon reflection, captured by the complex cavity reflection coefficient \( r_c(\delta) \). The PDH error signal is obtained by detecting the reflected beam and demodulating the photocurrent at the modulation frequency, isolating the beat terms between carrier and sidebands. The resulting signal is proportional to the \textit{imaginary part} of \( r_c(\delta) \), which varies antisymmetrically with detuning and provides a zero-crossing error signal ideal for linear feedback. The error signal near resonance is then given by 
\begin{equation}
\epsilon(\Delta \omega) \propto \mathfrak{Im} \Bigl(r_c(\Delta \omega)\Bigr)\simeq \Delta \omega
\end{equation}
This imaginary component encodes the rapid phase dispersion near resonance that allows the system to discriminate the sign and magnitude of frequency deviations. In contrast, the real part of \( r_c(\delta) \), being symmetric around resonance, does not yield a usable error signal. The PDH lock is generally preferred to the dither lock due to its superior sensitivity, larger linear range, and reduced susceptibility to technical noise. \\

The \textit{demodulation phase} plays a critical role in selecting the appropriate quadrature of the signal for feedback in both PDH and dither locks. For the PDH, since the beat signal between the carrier and sidebands has both in-phase and quadrature components, choosing the correct demodulation phase ensures that the extracted error signal aligns with the imaginary part of the reflection coefficient. A misaligned demodulation phase can lead to mixing of the symmetric (real) part into the error signal, thereby reducing sensitivity and introducing offset or distortion near the lock point. In practice, the demodulation phase is optimized empirically---either via a variable phase shifter in the electronic demodulation path or by adjusting the physical delay in the reference oscillator---to maximize the slope of the error signal at zero-crossing.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/PDHplots.pdf}
    \caption{
        PDH/Dither error signal dependence on the demodulation phase. (a) Ideal PDH error signal shape when the demodulation phase is correctly set to isolate the imaginary part of the cavity reflection coefficient. (b) Distorted error signal when the demodulation phase is misaligned, leading to mixing of the real part and reduced sensitivity.
    }\label{fig:PDH_scheme}
\end{figure}



\subsection{Offset Frequency Locks and Phase Lock Loop}
Finally, we discuss the implementation of frequency offset locks and phase lock loops (PLL) using the IQ modules in PyRPL. These techniques are essential for stabilizing the frequency offset and the relative phase of the beatnote between two lasers. The RP wiring diagram is shown in figure \ref{fig:Tfreq}. \\
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{./chap3/fig/Tfreq.pdf}
    \caption{RP wiring for frequency offset lock and phase lock loop (PLL) implementations. The beatnote between two lasers is detected on a fast photodiode, and the signal is demodulated using an IQ module at a frequency close to the desired offset frequency. The phase of the demodulated signal is evaluated using a CORDIC algorithm to generate the error signal, and subsequently locked to the RF reference using a PI controller that adjusts both the piezoelectric actuator and the temperature of the slave laser.
    }
    \label{fig:Tfreq}
\end{figure}

The basic principle is to detect the beatnote between two lasers on a fast photodiode, and to demodulate this signal using an IQ module at a frequency close to the desired offset frequency. The error signal is then derived from one of the quadratures of the demodulated signal. The error signal near the lock point is then given by
\begin{equation}
\varepsilon(\Delta \omega_{\mathrm{beat}}) \propto \Delta \omega_{\mathrm{beat}}
\end{equation}
where \( \Delta \omega_{\mathrm{beat}} = \omega_{\mathrm{beat}} - \omega_{\mathrm{ref}} \) is the deviation of the beatnote frequency from the reference frequency. This error signal is then fed into a PI controller, which adjusts the frequency of one of the lasers (typically via a piezoelectric actuator or current modulation) to maintain the desired offset frequency. \\

As explained before, a high voltage piezoelectric actuator has a limited bandwidth, typically up to a few kHz, due to the naturally occuring lowpass filtering effect of the piezo capacitance and the output impedance of the driving electronics. To overcome this limitation, we resort to the so called floating ground technique, which consists in locking both the piezo actuator through a standard PI loop, as well as locking the piezo ground to a higher frequency without amplifying it (or using an Operational Amplifier with high bandwidth i.e. OP27? 37?). This technique effectively extends the bandwidth of the piezo actuator up to a few tens of kHz, allowing for more robust and stable locks. Additionally, the laser current or temperature (the case here), is also locked to ensure the piezo remains in its mid-range of operation. Although not detailed in figure \ref{fig:Tfreq}, the temperature can be locked using the PyRPL PWM module, such that the modulated pwm signal (duty cycle) is sent to the laser temperature controller. The heating element of the laser will then naturally lowpass filter the pwm signal, providing a smooth and stable temperature control. This dual feedback approach enhances the overall stability and performance of the frequency offset lock and PLL. \\

